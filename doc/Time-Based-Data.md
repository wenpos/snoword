## 时序数据（Time-Based Data） ##

**前言**  
本章介绍ES的时序数据管理，如日志一类的时序数据，其随着时间增长迅速累积，文档却基本不更新，用于检索的也是通常是最近的文档，同时随着时间推移，老的文档逐渐失去价值。基于这类数据，我们应该针对其特点设计index，对其进行有效管理。

###时间结构化index（Index per Time Frame）###

如果我们将这这类时序数据全部放在一个大的index中进行管理，存储空间将很快溢出。以日志为例，日志事件不断地写入，我们虽然可以使用scroll query和bulk delete清理数据，但是这种方法效率非常低。同时，即使你删除一个文档，其并不是马上被物理删除，而是被标记成待删除状态，只有当segment合并(merge)时才会真正删除。因此，这种清理数据的方法，其效率十分有限，而最有效的数据清理方式就是删除index。   

因此，我们可以使用时间结构化index管理日志数据，根据相应的数据规模，我们可以按照小时、天、周、月以及年为单位创建index，例如按天创建index(logs_2017-03-21)等等。一旦某些数据正真过期，我们可以使用curator等工具并根据时间范围清理indices，同时对于不经常查询的index，但尚未过期的数据，可以进行相应的segment合并优化，减少存储资源的占用。  

这种管理时序数据的方法好处在于，你可以使用根据自己需求控制index规模和清理时机，每天你都机会定制index以满足当前变化的需求，也许开始的时候，你仅仅需要一个分片的周级别的index，稍后随着业务量的增加，你可能需要5个分片的天级别的index，但是，这些都无关紧要，因为你可以随时适应新的数据规模和业务量。反过来，若是将这些数据全部放在一个index中管理，其数据处理起来复杂，且效率低。

###别名管理index（Aliases Transparent）###
基于时间结构化的index虽然胜在可扩展、适应性强、清理方便，但是在查询方面却显得有些为难：难道查询天级别的30个index的数据，我们需要传入30个index吗？显然这不是我们建立时序化index的初衷，ES针对这种情况，提供了index别名管理机制，若是我们将上述30个index映射到一个相同的别名，当我们需要查询这些index时，我们只需传入这个共同的别名即可，而也不影响上述提到的index清理策略。

